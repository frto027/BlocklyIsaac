# 游戏流程与`回调`积木

回调积木用来告知游戏在特定的时刻执行某一段程序。

在大多数情况下，游戏的核心逻辑以[单线程](https://baike.baidu.com/item/%E5%8D%95%E7%BA%BF%E7%A8%8B/6972534?fr=aladdin)的方式在运作。这也就是说，游戏在同一时刻只会做一件事情。
如果感兴趣的话，我们可以通过这张<a href="../../../../../media/callbacks/Callbacks_zh-hans.svg">回调图</a>来了解游戏的一个大致运行流程（该图片译自[IsaacDoc](https://moddingofisaac.com/docs/rep/images/infographics/Isaac%20Callbacks.svg)文档）。

# 注册一个`回调`

我们可以通过`注册回调`的方式来告知游戏在某一时刻执行一段程序，同时还可以得到一些在这一时刻的相关游戏信息，以及向游戏提供一些信息来决定游戏的行为。

`工具块`中，提供了两个预先搭建好的积木，用来帮助我们注册回调：

![图 1](images/8a61d03c69ed9d2f46a4510ec7e3890c128dbed2687966f204509d937822758b.png)  

## 注册一个mod

工具块中的`注册Mod`积木告知游戏我们当前的mod名字。只有先放置这个积木，才能够去注册回调函数，完成后续操作。

![图 2](images/4a192e363fe0d10281a36d59f51b352d39759f161adf468fd01274b5c9851d85.png)  


它有两个参数：

- `mod名`告知游戏我们的mod名字是什么。为了避免bug，尽量不要用中文名字。
- `应用程序接口版本号`写1就可以，可不用关心细节。它指的是游戏的mod系统接口的版本号，这个参数是用来做兼容支持的。换句话说，这里的数字表示我们的mod是写给哪一个版本的游戏的，目前只有1，不要填写其它数字。我原本以为忏悔的mod会把这个数字改成2的，这样游戏就能通过这个数字来区分mod适用的游戏版本，但官方并没有这样做，这就表示，官方认为`忏悔`的mod和`胎衣+`的mod在行为上没有不同，即游戏不会去主动兼容mod（而是反过来，mod需要去判断游戏的版本来兼容游戏）。

不论后续有多少个回调参数，一个mod**只应该出现一个`注册Mod`的积木，且这个积木只应该被执行一次**。出现多个`注册Mod`或许也没有问题，但这不符合编程规范，有概率出现意想不到的Bug，不要这样做。

我们可以看到，它将一个`Mod引用`放到了一个叫做`我的mod`的`变量`上。关于`变量`的使用会在之后做介绍。

此外`Mod引用`还承担了mod数据存储的功能，这部分目前还没有做测试，相关使用方式会在后续过程中完善。

## 注册一个回调

我们可以在注册mod之后来设置回调函数。也就是使用`置回调函数`积木：

![图 3](images/5d9bdec09f1c191aba744114153ac9c8ef06e271ba8a52541085bfbae87dc997.png)  

这个积木需要三个或者四个参数。

- `操作对象`，就是我们之前注册的那一个mod，默认已经写好了，这里不用关心。
- `回调ID`，就是我们要在什么时候执行程序
- `回调函数`，就是要执行的那一个程序
- `第四个参数`，这个参数的类型和名字会随着`回调ID`来变化，含义也不一样

## 注册多个回调

可以通过多次摆放`置回调函数`积木来注册多个回调，这也是大多数mod做的事情。

![图 4](images/157d05506d11ad66607252fa8755d1e09d0089ad30df16ac2637594ea2a62b35.png)  

*请测试你的回调是否能够正常工作，比如因为游戏设计上的BUG，有些回调每个mod只能设置一次，有些回调一个mod设置了，另一个mod就无法再设置*

## 回调参数

回调参数表示游戏在执行这个回调的时候，为我们提供的一些附加信息，当我们选中一个`置回调函数`的积木的时候，左侧的工具箱里就会出现对应的回调参数：

![图 5](images/f52afda083655461669200b23c7d808fcfb1d93cd54d937fb9081aa544df3700.png)  

比如，上面的`NPC实体`就表示触发`回调_NPC_更新`的那一个`NPC实体`。

## `返回`积木

我们可以使用`返回`积木来告知游戏一些特殊信息：

![图 6](images/fa005a31134e1eefddba34b5676fe5b159f53d04a9a49ac45dbcca5ef1183469.png)  


比如，`取得卡牌`的回调不但能让我们在游戏获取一张卡牌的时候执行一段程序，还可以改变游戏取得的卡牌的结果。下面的程序会将所有的`取得卡牌`的结果替换为`卡牌_FOOL`，也就是`The Fool`卡牌：

![图 7](images/efc249c98e99155e8e38d37f335c4cd43d847b5308004838aa4c25b4f2666f91.png)  

<span b-url='bi-docs/bi-docs-cn/docs/text_tutorial/biml/5.return_sample.biml' />

执行后，可以看到，游戏中只会生成`The Fool`卡牌（输入控制台指令`spawn 5.300`试试看吧）。

此外，`返回`积木会让当前正在执行的mod逻辑终止（就像它的形状那样，它的后面不能跟任何的积木）。

有些不太和谐的是，`返回`终止掉的是整个`函引`积木的执行，所以下面的程序在第一层的时候并不会给角色增加黑心——因为一旦触发了`如果`的条件，导致`返回`被执行，那么整个`函引`都会直接中断，后续的`增加黑心`也就不会正常执行了：

![图 8](images/ced3c8ee08ce98b5174fa88ac568d329e96d101bcfa2d3187dcb7dd0facd00f5.png)  

<span b-url='bi-docs/bi-docs-cn/docs/text_tutorial/biml/5.return_sample_stop.biml' />

上面的程序的效果是：在第一层，将所有的卡牌替换为`The Fool`，否则（在其它层），每生成一张卡牌，就给角色增加一颗黑心。

# 回调列表

下面详细介绍每一种回调的使用方式。

（等我慢慢更新）